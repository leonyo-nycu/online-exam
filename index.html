<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>線上考卷作答工具</title>
<style>
    /* ... (其他 CSS 樣式保持不變) ... */

    /* 5. 控制項懸浮區 */
    #wb-controls {
        position: absolute; 
        top: 10px;
        left: 10px;
        z-index: 10; 
        
        padding: 8px 12px;
        background-color: rgba(255, 255, 255, 0.9);
        border-radius: 8px;
        border: 1px solid #ccc;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        user-select: none; 

        /* 【！！！核心修正點：抵消瀏覽器縮放！！！】 */
        /*
         * 我們不能直接使用 transform: scale(1/zoom-level)，
         * 但可以嘗試使用 fixed 屬性來分離它。
         */
        position: fixed; /* 將定位從 relative 變為 fixed，這樣它就不會被頁面內容的尺寸影響 */
        /* 【！！！注意：position: fixed 後，top/left 都是相對於瀏覽器視窗！！！】 */
    }
    
    /* 6. 控制項美化 */
    #wb-controls input[type="color"] {
        /* ... 保持不變 ... */
    }
    /* ... (其他控制項樣式保持不變) ... */
</style>
</head>
<body>

<div id="whiteboard-container">
    <div id="canvas-wrapper">
        <img id="wb-background-img" src="" alt="考卷背景圖片" />

        <canvas id="wb-canvas"></canvas>

        <div id="wb-controls">
            <input type="color" id="wb-color" title="筆跡顏色" value="#000000">
            <input type="range" id="wb-width" title="筆跡粗細" min="1" max="15" value="3">
            <button id="wb-clear" title="清除所有作答筆跡">清除</button>
            <button id="wb-save" title="儲存包含作答的圖片">儲存作答</button>
        </div>
    </div>
</div>

<script>
    window.addEventListener('load', function() {
        const canvas = document.getElementById('wb-canvas');
        const ctx = canvas.getContext('2d');
        const backgroundImg = document.getElementById('wb-background-img');
        const clearButton = document.getElementById('wb-clear');
        const saveButton = document.getElementById('wb-save');
        const colorPicker = document.getElementById('wb-color');
        const lineWidthControl = document.getElementById('wb-width');
        
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        // 【！！！確認使用正確的檔名！！！】
        const BACKGROUND_IMAGE_URL = '20251122223641558_page-0001.jpg'; 
        // --------------------------------------------------------
        
        // 將圖片 URL 賦值給 IMG 標籤，啟動載入
        backgroundImg.src = BACKGROUND_IMAGE_URL; 

        function setCanvasSize() {
            // 確保 Canvas 的繪圖解析度與圖片的原始像素尺寸匹配
            canvas.width = backgroundImg.naturalWidth;
            canvas.height = backgroundImg.naturalHeight;
            
            // 重設繪圖屬性
            ctx.strokeStyle = colorPicker.value;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.lineWidth = lineWidthControl.value;
        }

        backgroundImg.onload = function() {
            setCanvasSize();
            console.log(`圖片載入成功！Canvas 解析度設定為 ${canvas.width}x${canvas.height}`);
        };

        backgroundImg.onerror = function() {
            console.error("圖片載入失敗，請檢查檔名。");
            alert("考卷圖片載入失敗！請確認圖片檔名是否正確。");
        };

        // --- 核心繪圖函數 ---
        function getCoordinated(e) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            let x, y;
            
            if (e.touches && e.touches.length > 0) { 
                x = (e.touches[0].clientX - rect.left) * scaleX;
                y = (e.touches[0].clientY - rect.top) * scaleY;
            } else { 
                x = e.offsetX * scaleX;
                y = e.offsetY * scaleY;
            }
            return { x, y, scaleX };
        }

        function draw(e) {
            if (!isDrawing) return; 
            
            // 僅在單指觸控移動時阻止預設行為 (繪圖)
            if (e.touches && e.touches.length === 1) { 
                e.preventDefault();
            }
            
            const { x: currentX, y: currentY, scaleX } = getCoordinated(e);
            
            ctx.strokeStyle = colorPicker.value;
            ctx.lineWidth = lineWidthControl.value * scaleX; 

            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineTo(currentX, currentY);
            ctx.stroke();

            lastX = currentX;
            lastY = currentY;
        }

        function handleStart(e) {
            // 只有單指觸控或滑鼠點擊才算開始繪圖
            if (e.touches && e.touches.length > 1) {
                isDrawing = false; 
                return;
            }

            isDrawing = true;
            
            // 只有單指觸控時，才阻止預設行為
            if (e.touches && e.touches.length === 1) e.preventDefault(); 

            const { x, y } = getCoordinated(e);
            lastX = x;
            lastY = y;
        }

        function handleEnd() {
            isDrawing = false;
        }

        // 事件監聽
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('touchstart', handleStart, { passive: false });
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchmove', draw, { passive: false });
        canvas.addEventListener('mouseup', handleEnd);
        canvas.addEventListener('mouseout', handleEnd);
        canvas.addEventListener('touchend', handleEnd);
        canvas.addEventListener('touchcancel', handleEnd);

        // --- 控制項功能 (保持不變) ---
        clearButton.addEventListener('click', () => {
             ctx.clearRect(0, 0, canvas.width, canvas.height);
        });
        
        saveButton.addEventListener('click', () => {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = canvas.width;
            tempCanvas.height = canvas.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(backgroundImg, 0, 0, canvas.width, canvas.height);
            tempCtx.drawImage(canvas, 0, 0, canvas.width, canvas.height);
            const a = document.createElement('a');
            a.href = tempCanvas.toDataURL('image/png');
            a.download = '考卷作答結果.png';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            tempCanvas.remove();
        });

        colorPicker.addEventListener('change', (e) => {
            ctx.strokeStyle = e.target.value;
        });
        
        lineWidthControl.addEventListener('change', (e) => {
            ctx.lineWidth = e.target.value;
        });
    });
</script>
</body>

</html>



